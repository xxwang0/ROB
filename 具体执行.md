## 1、流出
首先同时有空闲保留站和ROB项时可以流出，然后检查rs寄存器的状态，里面值是否就绪，若被其他指令占用，再检查对应ROB里面的值是否就绪，若就绪，直接把值给保留站的vj，未就绪把ROB编号放在保留站的Qj,否则，直接把值给保留站的vj。
 如果是浮点运算或存储操作,再检查rt,然后是目的寄存器rd
 Store和load 存立即数
```
void issue(int time) {
    if (!q.empty()) {
        int x = q.front();    
        int r = find_free_RS(); // 找到一个空闲的保留站
        int b = find_free_ROB(); // 找到一个空闲的ROB项
        if (r == -1 || b == -1) {
            cout << "No free reservation station or ROB entry available.\n";
            return;
        }
        // 检查源寄存器的状态
        if (RegStat[rs].busy) {
            int h = RegStat[rs].reorder;
            if (ROB[h].ready) {
                RS[r].Vj = ROB[h].value; // 如果ROB头指令完成则取数
                RS[r].Qj = 0;
            } else {
                RS[r].Qj = h; // 否则，等待指令
            }
        } 
        else {
            RS[r].Vj = Regs[x]; // 若寄存器空闲，直接取数
            RS[r].Qj = 0;
        }

        RS[r].busy = true;
        RS[r].Dest = b;
        ROB[b].instruction = op;
        ROB[b].dest = rt;
        ROB[b].ready = false;

        // 如果是浮点运算或存储操作
        if (op == "ADD" || op == "SUB" || op == "MUL" || op == "DIV" || op == "STORE") {
            if (RegStat[rt].busy) {
                int h = RegStat[rt].reorder;
                if (ROB[h].ready) {
                    RS[r].Vk = ROB[h].value; // 如果ROB头指令完成则取数
                    RS[r].Qk = 0;
                } else {
                    RS[r].Qk = h; // 否则，等待指令
                }
            } else {
                RS[r].Vk = Regs[rt]; // 若寄存器空闲，直接取数
                RS[r].Qk = 0;
            }
        }

        // 对于浮点操作
        if (op == "ADD" || op == "SUB" || op == "MUL" || op == "DIV") {
            RegStat[rt].reorder = b;
            RegStat[rt].busy = true;
            ROB[b].dest = rt;
        }

        // 对于store操作
        if (op == "STORE") {
            RS[r].A = imm;
        }

        // 对于load操作
        if (op == "LOAD") {
            RS[r].A = imm;
            RegStat[rt].reorder = b;
            RegStat[rt].busy = true;
            ROB[b].dest = rt;
        }
    }
}
```
### 找空闲保留站和ROB
```
int find_free_LoadRS() {
    for (int i = 0; i < 3; ++i) {
        if (!LoadRS[i].Busy) {
            return i;
        }
    }
    return -1; // 没有空闲的Load保留站
}
int find_free_AddRS() {
    for (int i = 0; i < 3; ++i) {
        if (!LoadRS[i].Busy) {
            return i;
        }
    }
    return -1; // 没有空闲的加法保留站
}
int find_free_MultRS() {
    for (int i = 0; i < 3; ++i) {
        if (!LoadRS[i].Busy) {
            return i;
        }
    }
    return -1; // 没有空闲的乘法保留站
}

int find_free_ROB() {
    for (int i = 1; i <= 6; ++i) { // 假设有6个ROB项
        if (!ROB[i].Busy) { // 如果ROB项未被占用
            return i; // 返回该ROB项的索引
        }
    }
    return -1; // 如果没有空闲的ROB项，返回-1表示未找到
}

```

## 2、执行
```
void execute(int time){
	if (op == "ADD" || op == "SUB" || op == "MUL" || op == "DIV"){
		if (RS[r].Qj == 0 && RS[r].Qk == 0) {
        // 计算结果
        float result = RS[r].Vj + RS[r].Vk; // 假设为加法操作
        // 将结果存储到 ROB 中
        ROB[RS[r].Dest].value = result;
        ROB[RS[r].Dest].ready = true;
    }
	}
	if (op == "Load" ){
		if (RS[r].Qj == 0) {
        RS[r].A = RS[r].Vj + RS[r].A;
        ROB[RS[r].Dest].value = Mem[RS[r].A];
        ROB[RS[r].Dest].ready = true;
    }
	}
	if (op == "Store" ){
		if (RS[r].Qj == 0) {
        ROB[RS[r].Dest].address = RS[r].Vj + RS[r].A;
        // 其他存储相关操作
    }
	}
	
}
```

## 3、写结果
获取当前指令的目标 ROB 条目索引 b。
将当前保留站 r 置为非忙状态。
遍历所有保留站，更新所有依赖于当前指令结果的保留站的状态，并将结果写入相应的 Vj 或 Vk 中。
将结果写入 ROB 中，并将该 ROB 条目标记为就绪状态。
```
// 假设执行结果写回阶段的函数
void execute_write_result(int r, float result) {
    int b = RS[r].Dest; // 取得目标 ROB 条目索引

    RS[r].busy = false; // 将当前保留站置为非忙状态

    // 更新所有依赖于当前指令结果的保留站的状态
    for (int x = 0; x < RS.size(); ++x) {
        if (RS[x].Qj == b) {
            RS[x].Vj = result; // 将结果写入 Vj
            RS[x].Qj = 0; // 清除 Qj
        }
        if (RS[x].Qk == b) {
            RS[x].Vk = result; // 将结果写入 Vk
            RS[x].Qk = 0; // 清除 Qk
        }
    }

    // 将结果写入 ROB
    ROB[b].value = result;
    ROB[b].ready = true; // 标记为就绪状态
}

```
## 4、提交
在 commit_instruction() 函数中，首先检查 ROB 中头部指令是否已经就绪。如果是，则根据指令类型执行相应的操作。
处理分支指令：如果是分支指令并且预测错误，清除 ROB 条目和目标寄存器状态，并获取正确的分支目标。
处理存储指令：将存储指令的值写入内存中的目标地址。
处理其他指令：将其他指令的计算结果写入目标寄存器。
释放资源：释放 ROB 条目，并根据需要释放目标寄存器状态。
```
// 假设提交阶段的函数实现
void commit_instruction() {
    // 确认要处理的指令位于 ROB 的头部且已就绪
    if (!ROB.empty() && ROB[0].ready) {
        int h = 0; // ROB 头部索引
        int d = ROB[h].dest; // 目标寄存器索引

        if (ROB[h].instruction == "Branch") {
            // 处理分支指令
            if (branch_mispredicted) {
                // 分支预测错误时的处理
                clear_ROB_entry(h); // 清除 ROB 条目
                clear_RegisterStat(d); // 清除目标寄存器状态
                fetch_branch_dest(); // 获取分支目标地址
            }
        } else if (ROB[h].instruction == "Store") {
            // 处理存储指令
            Mem[ROB[h].dest] = ROB[h].value; // 存储到内存
        } else {
            // 处理其他指令，将结果写入目标寄存器
            Regs[d] = ROB[h].value;
        }

        // 释放 ROB 条目
        ROB[h].busy = false;

        // 如果没有其他指令正在写入目标寄存器，则释放目标寄存器
        if (RegisterStat[d].reorder == h) {
            RegisterStat[d].busy = false;
        }
    }
}

// 清除 ROB 条目函数
void clear_ROB_entry(int h) {
    ROB[h].instruction = ""; // 清除指令类型
    ROB[h].dest = -1; // 清除目标寄存器索引
    ROB[h].ready = false; // 状态置为未就绪
    ROB[h].value = 0; // 清除值
    ROB[h].address = 0; // 清除地址（如果有的话）
}

// 清除寄存器状态函数
void clear_RegisterStat(int d) {
    RegisterStat[d].reorder = -1; // 清除重排序索引
    RegisterStat[d].busy = false; // 置为非忙状态
}
```
