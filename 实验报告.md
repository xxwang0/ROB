# 一：项目简介
基于ROB扩展Tomasulo算法是一种用于动态调度指令执行的技术，通常应用于超标量处理器中。该算法通过指令发射、操作数就绪、执行、结果写回等步骤实现指令的乱序执行和并行处理。<br>
它利用Reservation Station跟踪指令的操作数是否可用性；<br>
使用重命名表来处理异常和维护执行状态。通过分支预测和乱序执行，基于ROB扩展Tomasulo算法能够最大程度地提高处理器的性能和效率。<br>
# 二、项目原理
## 前置知识
### Tomasulo算法：
优点：<br>
1、Tomasulo引入保留站之后，通过寄存器重命名技术有效地解决了写后写数据冒险问题。在Tomasulo算法中，发生写后写冒险时总是把最新的值写进寄存器，旧值不写进寄存器，但是广播；<br>
2、通过寄存器重命名技术有效地解决了读后写数据冒险问题。Tomasulo算法里不会出现读后写冒险，因为指令一旦发射，指令就会把能读取的数据保存到保留站，源寄存器是否被改写就与该指令无关。<br>
缺点：<br>
1、Tomasulo算法没办法处理中断，精确中断是指在指令和指令之间如果出现了中断/异常，那么处理器要确保中断/异常之前的所有指令都执行完毕，而中断/异常之后的所有指令都没有执行。Tomasulo并不支持指令按序提交，如果指令没办法按序提交，那就很难处理分支指令，如果有分支预测且分支预测失败的话，很难恢复处理器状态。<br>
2、Tomasulo算法如果在一个周期内同时多条指令就绪或者多条指令写回，受制于总线以及执行单元数量，无法实现完全并行。并且处理多发射指令时，需要增加寄存器读写口，增加控制逻辑。<br>
3、Tomasulo算法在处理存储指令的冲突时，需要额外加入控制逻辑以及硬件支持。
### 基于ROB扩展的Tomasulo算法
1、在Tomasulo算法中，指令的提交是乱序的，分支指令难以处理。为了解决这个问题，引入了ROB，作为指令执行的缓冲区。ROB保持指令的执行顺序，并在指令执行完毕后等待有序提交。<br>
2、ROB是一个类似FIFO队列的结构，其中包含了每条指令的信息，如ROB编号、Busy位、状态位、Dest和Value等字段。指令在发射时被分配ROB编号，等到执行完毕后再提交。ROB的结构允许指令在执行完毕后保持在队列中，而不立即修改逻辑寄存器。 指令在ROB中按照它们在程序中的顺序等待提交。当一条指令成为ROB中最老的指令时，即ROB的头指针指向该指令，就可以有序提交。这确保了指令在逻辑寄存器中的修改按照程序顺序完成。与此同时，ROB也能代替RS的作用实现寄存器重命名，从而保证指令的效率。<br>
3、ROB的有序提交机制实现了精确中断，确保了在中断发生时能够保持指令的有序提交，而不会导致程序执行错误。ROB的引入允许在指令执行时清除保留站，从而提高了后续指令的发射效率。通过引入ROB，改进的Tomasulo算法克服了原始Tomasulo算法中的一些限制，使得乱序执行更符合程序员的预期，并提高了整体的性能和灵活性。<br>
ROB的缺点<br>
1、重排序缓存需要更多存储空间：在基于ROB扩展的Tomasulo算法中，一个逻辑寄存器的结果被拷贝到多个地方，数据可能存在逻辑寄存器中，也可能存在保留站中，也可能存在ROB中，即一个数据需要三倍于数据长度的存储空间，从而需要更多资源。<br>
2、重排序缓存需要更多的硬件资源：指令的源数据可以从寄存器堆、CDB总线和ROB中取得。为了支持指令读取数据，需要在 ROB 中配置读口，增加了处理器内部逻辑和数据传递的布线压力。可能导致关键路径的延长，从而影响整体性能。此外，为了处理 ROB 中的数据，需要在读取数据的线路末尾增加选择器，进一步增加了设计的复杂性。<br>
3、重排序缓存可能引入延迟：尽管 ROB 可以提高指令级并行性，但在某些情况下，指令需要等待 ROB 中的其他指令完成执行才能提交。这可能引入一定的延迟。<br>
4、重排序缓存在多发射处理器中具有很大难度。为了满足多个指令同时读取 ROB 中的状态，ROB 需要支持多个读端口。在四发射的机器中，如果每个指令都需要两个读端口，ROB 就需要支持八个读端口。这种多端口读的实现增加了硬件结构的复杂性，可能导致更大的芯片面积和更高的功耗，同时也增加了设计和验证的难度。
# 三、项目设计
![ ](https://github.com/xxwang0/ROB/assets/147365280/a3317637-725a-4783-b75c-818b089b37e1)
功能部件有ROB、RS保留站、FP浮点寄存器、总线、寄存器组、内存等。
# 四、技术路线/技术难点
# 五、代码详解
# 六、测试样例
# 七：实验结果与分析
