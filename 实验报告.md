# 一：项目简介
基于ROB扩展Tomasulo算法是一种用于动态调度指令执行的技术，通常应用于超标量处理器中。该算法通过指令发射、操作数就绪、执行、结果写回等步骤实现指令的乱序执行和并行处理。<br>
它利用Reservation Station跟踪指令的操作数是否可用性；<br>
使用重命名表来处理异常和维护执行状态。通过分支预测和乱序执行，基于ROB扩展Tomasulo算法能够最大程度地提高处理器的性能和效率。<br>
# 二、项目原理
## 前置知识
### Tomasulo算法：
优点：<br>
1、Tomasulo引入保留站之后，通过寄存器重命名技术有效地解决了写后写数据冒险问题。在Tomasulo算法中，发生写后写冒险时总是把最新的值写进寄存器，旧值不写进寄存器，但是广播；<br>
2、通过寄存器重命名技术有效地解决了读后写数据冒险问题。Tomasulo算法里不会出现读后写冒险，因为指令一旦发射，指令就会把能读取的数据保存到保留站，源寄存器是否被改写就与该指令无关。<br>
缺点：<br>
1、Tomasulo算法没办法处理中断，精确中断是指在指令和指令之间如果出现了中断/异常，那么处理器要确保中断/异常之前的所有指令都执行完毕，而中断/异常之后的所有指令都没有执行。Tomasulo并不支持指令按序提交，如果指令没办法按序提交，那就很难处理分支指令，如果有分支预测且分支预测失败的话，很难恢复处理器状态。<br>
2、Tomasulo算法如果在一个周期内同时多条指令就绪或者多条指令写回，受制于总线以及执行单元数量，无法实现完全并行。并且处理多发射指令时，需要增加寄存器读写口，增加控制逻辑。<br>
3、Tomasulo算法在处理存储指令的冲突时，需要额外加入控制逻辑以及硬件支持。
### 基于ROB扩展的Tomasulo算法
1、在Tomasulo算法中，指令的提交是乱序的，分支指令难以处理。为了解决这个问题，引入了ROB，作为指令执行的缓冲区。ROB保持指令的执行顺序，并在指令执行完毕后等待有序提交。<br>
2、ROB是一个类似FIFO队列的结构，其中包含了每条指令的信息，如ROB编号、Busy位、状态位、Dest和Value等字段。指令在发射时被分配ROB编号，等到执行完毕后再提交。ROB的结构允许指令在执行完毕后保持在队列中，而不立即修改逻辑寄存器。 指令在ROB中按照它们在程序中的顺序等待提交。当一条指令成为ROB中最老的指令时，即ROB的头指针指向该指令，就可以有序提交。这确保了指令在逻辑寄存器中的修改按照程序顺序完成。与此同时，ROB也能代替RS的作用实现寄存器重命名，从而保证指令的效率。<br>
3、ROB的有序提交机制实现了精确中断，确保了在中断发生时能够保持指令的有序提交，而不会导致程序执行错误。ROB的引入允许在指令执行时清除保留站，从而提高了后续指令的发射效率。通过引入ROB，改进的Tomasulo算法克服了原始Tomasulo算法中的一些限制，使得乱序执行更符合程序员的预期，并提高了整体的性能和灵活性。<br>
基于ROB扩展的Tomasulo算法，执行分为四个阶段，流出，执行，写结果，确认，具体过程如下：<br>
`流出`<br>
* 从FIFO队列中获取下一条指令,如果可用的RS项和ROB项，发出指令,如果RS或ROB项不可用，它就会成为结构冲突，并且指令停止,如果没有发出较早的指令，那么后续的指令不能发出<br>
* 如果操作数可用，读取它们并将它们存储在保留站。操作数可以从寄存器文件(已经提交的指令)或从ROB(已执行但尚未提交)中读取<br>
* 依赖于先前指令的操作数由Q字段中相应的ROB标签标识<br>
`执行`<br>
* 当所有操作数就绪时，发出执行指令，一旦指令进入执行阶段，就释放保留站，通过有效地址按程序顺序维护加载和存储。即使有挂起的分支，指令也是预测性执行的
`写结果`<br>
* 当结果可用时，将其写入CDB，并从CDB写入ROB，以及写入等待该结果的任何保留站。如果要存储的值还不可用，则必须监视CDB，直到该值被广播。
  `确认`
* 根据提交指令是具有错误预测的分支、存储还是任何其他指令(正常提交)，提交时有三种不同的操作序列。正常的提交情况发生在指令到达ROB的头部并且其结果存在于缓冲区时;此时，处理器用结果更新寄存器，并从ROB中删除该指令
* 提交存储与此类似，只是更新的是内存而不是结果寄存器。当一个预测不正确的分支到达ROB的头部时，它表明猜测是错误的。刷新ROB，并在分支的正确后继者处重新开始执行。如果正确预测了该分支则该分支完成。有些机器称这个提交阶段为完成或毕业。 

ROB的缺点<br>
1、重排序缓存需要更多存储空间：在基于ROB扩展的Tomasulo算法中，一个逻辑寄存器的结果被拷贝到多个地方，数据可能存在逻辑寄存器中，也可能存在保留站中，也可能存在ROB中，即一个数据需要三倍于数据长度的存储空间，从而需要更多资源。<br>
2、重排序缓存需要更多的硬件资源：指令的源数据可以从寄存器堆、CDB总线和ROB中取得。为了支持指令读取数据，需要在 ROB 中配置读口，增加了处理器内部逻辑和数据传递的布线压力。可能导致关键路径的延长，从而影响整体性能。此外，为了处理 ROB 中的数据，需要在读取数据的线路末尾增加选择器，进一步增加了设计的复杂性。<br>
3、重排序缓存可能引入延迟：尽管 ROB 可以提高指令级并行性，但在某些情况下，指令需要等待 ROB 中的其他指令完成执行才能提交。这可能引入一定的延迟。<br>
4、重排序缓存在多发射处理器中具有很大难度。为了满足多个指令同时读取 ROB 中的状态，ROB 需要支持多个读端口。在四发射的机器中，如果每个指令都需要两个读端口，ROB 就需要支持八个读端口。这种多端口读的实现增加了硬件结构的复杂性，可能导致更大的芯片面积和更高的功耗，同时也增加了设计和验证的难度。
# 三、项目设计
![ ](https://github.com/xxwang0/ROB/assets/147365280/29f6d4d9-514e-4ef3-96b7-3f783bb9795f)

![ ](https://github.com/xxwang0/ROB/assets/147365280/a3317637-725a-4783-b75c-818b089b37e1)
功能部件有ROB、RS保留站、FP浮点寄存器、总线、寄存器组、内存等。
## 伪代码
![ ](https://github.com/xxwang0/ROB/assets/147365280/3debaedb-eb6d-48df-9969-b56d6bee36d2)

# 四、技术路线/技术难点
当你设计和实现基于你的伪代码的仿真器，并准备撰写实验报告时，可能会面临以下具体的技术路线和技术难点：
## 技术路线：
1. 指令流出逻辑的实现：<br>
   * 首先需要理解和实现指令流出的过程。这包括从寄存器文件（Regs）、寄存器状态表（RegStat）、ROB 表和保留站表（RS）中分配和释放资源。<br>
   * 确保正确处理指令的就绪状态，例如通过检查 ROB 中指令的 Ready 标志来判断指令是否可以执行。<br>
2. 状态管理：<br>
   * 实现寄存器状态表（RegStat）和 ROB 表，用于跟踪每个寄存器和 ROB 项的状态。确保能够正确地更新和查询这些状态，以便指导指令的流出和执行。<br>
3. 指令执行：<br>
   * 实现各种类型指令的执行逻辑，包括整数运算、浮点运算、加载和存储操作。确保正确处理数据依赖关系，只有在相关的操作数就绪时才执行指令。<br>
4. 数据相关性检测：<br>
   * 维护数据相关性链，以确保指令在满足数据依赖关系的条件下执行。这可能涉及到检查和更新保留站中操作数就绪的状态。<br>
5. 内存和寄存器模拟：<br>
   * 实现内存和寄存器的模拟，确保能够正确地加载和存储数据。对于加载（load）操作，需要将内存中的数据加载到寄存器或保留站中；对于存储（store）操作，需要将寄存器中的数据写入内存。<br>
6. 指令提交和结果写回：<br>
   * 确保指令执行完毕后能够正确提交结果到 ROB，并在适当时机将结果写回到寄存器或内存中。这包括更新 ROB 中指令的状态和结果，并释放相关的保留站和寄存器状态。<br>
## 技术难点：
1. 并发和同步问题：<br>
   * 处理指令的并发执行和资源的竞争问题。需要考虑如何有效地管理和分配保留站和 ROB 的资源，以及如何在多个指令之间进行合理的同步和调度。<br>
2. 异常处理和分支预测：<br>
   * 实现异常处理机制，特别是在分支预测失败时的回滚操作。需要正确地处理异常情况，如清除 ROB 和寄存器状态，并正确恢复程序执行流程。<br>
3. 性能优化：<br>
   * 考虑如何优化模拟器的性能，例如通过并行处理、缓存优化和指令调度等技术手段来提高仿真器的运行效率。<br>
4. 调试和测试：<br>
   * 编写全面的测试用例和调试工具，确保仿真器能够正确地模拟各种指令和特殊情况。特别是对于边界条件和异常情况，需要进行充分的测试和验证。<br>
5. 实验结果分析：<br>
   * 在实验报告中详细分析仿真器的性能、效率和正确性。结合仿真结果对比和数据分析，评估仿真器的优缺点，并提出可能的改进和优化方案。<br>

# 五、代码详解

# 六、测试样例
```
	LWS F0 10(R1) //从地址为 10 + (R1) 的内存中加载数据，然后将其存储到寄存器 F0 中。
	ADDS F3 F0 F2 //将寄存器 F0 和 F2 中的内容相加，然后将结果存储到寄存器 F3 中
	MULTS F4 F0 F5 //将寄存器 F0 和 F5 中的内容进行乘法运算，然后将结果存储到寄存器 F4 中。
	BEQZ R3 TARGET //这行代码是一个条件分支指令。如果寄存器 R3 的值为零，则跳转到标签 TARGET 处继续执行。
	SUBS F2 F5 F4 //将寄存器 F5 中的值减去寄存器 F4 中的值，然后将结果存储到寄存器 F2 中。
	DIVS F6 F10 F0 //将寄存器 F10 的值除以寄存器 F0 的值，然后将商（整数部分）存储到寄存器 F6 中。
	ADDS F5 F7 F8 //将寄存器 F7 和 F8 中的值相加，然后将结果存储到寄存器 F5 中。
  TARGET:	ADDS F4 F2 F3 // 这是一个标签，标记了之前条件分支指令 BEQZ 的目标位置。在这里，寄存器 F2 和 F3 的值相加，然后将结果存储到寄存器 F4 中。
	SUBS F2 F5 F4 //再次执行了寄存器 F5 减去寄存器 F4 的操作，并将结果存储到寄存器 F2 中。
	EOP //这表示程序结束。在汇编语言中，EOP 通常用于标志程序的末尾或某个过程的结束。
```
# 七：实验结果与分析
